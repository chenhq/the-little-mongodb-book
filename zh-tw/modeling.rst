*******
資料塑模
*******

讓我們開始討論更加抽象化的 MongoDB 主題，\
解釋新的術語和語法並不困難，\
但是討論新典範的資料塑模就不是一件容易的事。\
我們之中多數的人，\
在使用新的技術塑模時，\
會持續發現什麼可以做、什麼不行，\
我們先從討論開始，\
最後你必須自己動手練習撰寫真正的程式碼。

和大多數 NoSQL 解決方案比較，\
在進行塑模時，\
文件導向資料庫和關聯式資料庫的差異並不大。\
儘管差異很微小，\
但瞭解這些差異還是很重要。

沒有 JOIN
========

第一個也是最根本的差異，\
就是 MongoDB 沒有 JOIN 的用法。\
我不清楚 MongoDB 不支援某些資料型別的特殊理由，\
但是我所知道的是 JOIN 被認定為不易延展（non-scalable）。
意思就是，當你開始水平切割你的資料，\
最後的 JOIN 動作必須在資料庫客戶端（通常是應用程式伺服器）完成。\
無論理由為何，\
實際的資料仍然是可以有關連，\
但 MongoDB 就是不支援 JOIN。

要在沒有 JOIN 的世界存活，\
我們只有在自己的程式碼實作 JOIN 這個辦法。\
基本上我們需要使用第二個 ``find`` 查詢相關的資料，\
我們對資料做的事情就如同在關聯式資料庫設定外來鍵（foreign key）一樣。\
我們暫時向獨角獸告別，\
花一些時間和我們的「員工」（\ ``employees``\  ），\
我們需要做的第一件事，\
就是建立一筆員工資料（為了範例的測試方便，我們明確指定 ``_id`` 欄位的值）：

::

    db.employees.insert({_id: ObjectId("4d85c7039ab0fd70a117d730"), name: 'Leto'})

接著我們增加一對員工，並將他們的主管設定為 ``Leto``\ ：

::

    db.employees.insert({_id: ObjectId("4d85c7039ab0fd70a117d731"), name: 'Duncan', manager: ObjectId("4d85c7039ab0fd70a117d730")});
    db.employees.insert({_id: ObjectId("4d85c7039ab0fd70a117d732"), name: 'Moneo', manager: ObjectId("4d85c7039ab0fd70a117d730")});

（請注意 ``_id`` 的值不能夠重複，你在實際撰寫程式也可能會使用 ``ObjectId``\ ，就如同這些範例。）

如果要找出所有 Leto 的員工，我們理當會這樣執行：

::

    db.employees.find({manager: ObjectId("4d85c7039ab0fd70a117d730")})

這邊沒有任何神奇之處，對於最差的狀況來說，\
沒有 JOIN 的功能，我們僅需要多一個額外的查詢（像是索引）。

陣列和內嵌文件
============

儘管 MongoDB 沒有 JOIN 功能，\
但我們還是可以透過一些技巧來達到同樣效果。\
還記得之前談過 MongoDB 支援將陣列作為文件的第一級物件（first class objects）？\
這個特性讓我們在實作多對一或多對多的關聯時，\
可以相當得心應手。\
舉個簡單的例子，如果一位員工有兩位主管，\
我們可以簡單地用陣列來儲存：

::

    db.employees.insert({_id: ObjectId("4d85c7039ab0fd70a117d733"), name: 'Siona', manager: [ObjectId("4d85c7039ab0fd70a117d730"), ObjectId("4d85c7039ab0fd70a117d732")] })

特別有趣的地方是，\
對於某些文件來說，\
``manager`` 可以是一般型態的資料，\
但某些則可以是陣列資料，\
我們原來的 ``find`` 不必修改就能同時查詢這兩種：

::

    db.employees.find({manager: ObjectId("4d85c7039ab0fd70a117d730")})

你很快就會發現，使用陣列來處理多對多關連表格簡單太多了。

除了陣列，MongoDB 也支援內嵌文件，\
以下的範例插入一筆巢狀的文件。

::

    db.employees.insert({_id: ObjectId("4d85c7039ab0fd70a117d734"), name: 'Ghanima', family: {mother: 'Chani', father: 'Paul', brother: ObjectId("4d85c7039ab0fd70a117d730")}})

內嵌文件可以使用「.」記號進行查詢：

::

    db.employees.find({'family.mother': 'Chani'})

我們很快就會討論到內嵌文件可以用在哪，以及你如何運用它。

DBRef
-----

MongoDB 支援一種名為 ``DBRef`` 的功能，\
有許多驅動程式都支援。\
當驅動程式有 ``DBRef`` 它就可以自動取出被參考到的文件。\
``DBRef`` 包括資料集合，\
還有被參考文件的主鍵（id），\
它一般用於一個特定的目的：當同一個資料集合的文件，參考了來自其他集合的文件，\
從文件1的 ``DBRef`` 可能會指向在 ``managers`` 的一筆文件，\
而文件2的 ``DBRef`` 可能指向 ``employees`` 的一筆文件。

反正規化
=======

另一種替代 JOIN 的辦法是將資料反正規化，\
過去的經驗是，反正規化通常是用於特別注重效能的程式碼，\
或者資料必須保留各階段的快照（像是稽核記錄）。\
然而，對愈來愈熱門的 NoSQL 來說，\
很多解決方案都不支援 JOIN，\
所以將反正規化用在一般的資料塑模變得很常見。\
這並不表示你需要將資訊重複出現在許多文件中，\
而是你需要克服對資料重複的恐懼，\
在資料塑模時考慮哪些資訊可以存在文件中。

舉例來說，當你在開發一個論壇的應用程式，\
傳統的方法是 ``user`` 需要在 ``post`` 建立 ``userid`` 欄位以建立關連，\
對這種資料模型來講，\
要顯示文章及發佈者，
你不可能只顯示 ``post`` 的資料而沒有連結（JOIN）\ ``user`` 的資料，\
而一種可能的解決方法，\
是簡單地將發佈者的名字 ``name`` 也保存在 ``post`` 資料表。\
這時候你可以使用內嵌文件，像是：
``user: {id: ObjectId('Something'), name: 'Leto'}`` 。\
當然，如果你讓使用者變更他們的名字，\
你就必須更新每一筆文件（需要多一次的查詢）。

要調整成這種方法，對於某些情況來說並不簡單。\
對於很多情況來講，這樣做可能不大有意義，\
但是請別害怕用這種方法做些實驗，\
它不僅適合某些情況，\
有時還是最正確的做法。

該選擇哪一種方法
--------------

用主鍵（id）建立的陣列對於一對多或多對多的情況通常都是有用的策略；\
而 ``DBRef`` 可能不會經常用到，\
你可能只拿它做實驗或玩一玩。\
通常新手會不太確定要使用內嵌文件，還是要手動處理資料的關聯。

首先，你必須知道每一個獨立的文件目前具有 4MB 容量的限制，\
知道文件有大小限制，讓你對文件要怎麼使用有一些構想。\
關於這一點，\
似乎大多數的開發者選擇自己動手處理關連資料，\
是否要用內嵌文件有時不容易評斷，\
但通常我們可以用它來保存小量的資料到母文件中，\
一個實際的案例是，\
我在每一個使用者的文件中，\
儲存 ``acounts`` 內嵌文件，像是：

::

    db.users.insert({name: 'leto', email: 'leto@dune.gov', account: {allowed_gholas: 5, spice_ration: 10}})

雖然有其限制，
但不表示你要低估內嵌文件的用處，\
或是認定它效果很少。\
直接將資料模型對映到你的物件，\
將會讓事情大幅簡化，\
而且經常可以免除 JOIN 的需要。\
因為 MongoDB 允許你對內嵌文件查詢以及作為索引欄位，\
使得內嵌文件有實際的用途。

資料集合的多或少
=============

因為資料集合沒有任何定義綱要（schema）的要求，
所以只用一個資料集合，\
把彼此不相干的資料都往裡面放，\
也同樣能建立一個系統。\
以我所見過的，\
大多數 MongoDB 系統，\
資料庫的設計和你在關聯式系統所看過的很相似，\
換句話說，\
如果你在關聯式資料庫建立一個資料表，\
那你也可以同樣在 MongoDB 建立一個資料集合（使用 JOIN 的多對多資料表是重要的例外情況）。\

當你開始考慮內嵌文件，這個討論就會開始變得更加有趣，\
最常出現的範例是部落格，\
你是要設計 ``posts`` 和 ``comments`` 兩個資料集合，\
還是將 ``comments`` 以陣列方式儲存在 ``posts`` 的每一筆文件中，\
暫時先別管 4MB 容量限制（Hamlet 全部也才 200KB，你的部落格有多熱門呢？），\
大多數的開發者，\
還是喜歡將資料分開處理，\
這樣做不僅簡單乾淨，也更加明確。

並沒有什麼強制規則告訴你該怎麼做（當然，除了 4MB 以外），\
試著玩玩看不同的方法，\
你將會知道怎樣做比較好。

重點回顧
=======

本章的目標是幫助你使用 MongoDB 時可以將資料塑模，\
對於文件導向系統來說，資料塑模和關聯式世界的差異並不多，\
你可以有多一點的彈性，但也有一個限制，\
對於開發新系統來說，你會找到合適的方案，\
但前提是你需要多嘗試，否則可能走向錯誤。
